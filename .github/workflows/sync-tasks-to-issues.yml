name: Sync Tasks to GitHub Issues

on:
  push:
    paths:
      - 'docs/tasks/**/*.md'
      - 'docs/STATE.md'
    branches:
      - main
  workflow_dispatch: # Allow manual triggering

# Prevent concurrent runs from conflicting
concurrency:
  group: sync-tasks-${{ github.ref }}
  cancel-in-progress: false

# GitHub Projects Integration Setup:
# 1. Create a project: gh project create --owner @me --title "<YourProject> Task Board"
# 2. Get the project number: gh project list --owner @me
# 3. Set PROJECT_NUMBER in GitHub repo settings:
#    Settings â†’ Secrets and variables â†’ Actions â†’ Variables â†’ New repository variable
#    Name: PROJECT_NUMBER, Value: <your-project-number>
# 4. Set GH_PROJECT_TOKEN (Personal Access Token with project scope):
#    Settings â†’ Secrets and variables â†’ Actions â†’ Secrets â†’ New repository secret
#    Name: GH_PROJECT_TOKEN, Value: <your-PAT>

env:
  PROJECT_NUMBER: ${{ vars.PROJECT_NUMBER }}

jobs:
  sync-tasks:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      issues: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Only need current and previous commit for diff

      - name: Validate required files
        run: |
          if [ ! -f "docs/STATE.md" ]; then
            echo "::error::docs/STATE.md not found"
            exit 1
          fi

          if [ ! -d "docs/tasks" ]; then
            echo "::error::docs/tasks directory not found"
            exit 1
          fi

      - name: Setup labels (idempotent)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Define labels with colors and descriptions
          declare -A LABELS=(
            ["backlog"]="E4E669:In backlog folder"
            ["next"]="FFA500:In next folder"
            ["in-progress"]="0E8A16:In working folder"
            ["review"]="C2E0C6:In review folder"
            ["completed"]="98FB98:In live folder"
          )

          # Create labels only if they don't exist
          for label in "${!LABELS[@]}"; do
            IFS=':' read -r color description <<< "${LABELS[$label]}"

            if ! gh label list --json name --jq '.[].name' | grep -q "^${label}$"; then
              gh label create "$label" --color "$color" --description "$description"
              echo "Created label: $label"
            fi
          done

      - name: Check if bulk sync is requested
        id: check-sync-flag
        run: |
          SYNC_ALL=$(grep -E '^\*\*SYNC_ALL_TASKS\*\*:\s*true' docs/STATE.md > /dev/null && echo "true" || echo "false")
          echo "sync_all=$SYNC_ALL" >> "$GITHUB_OUTPUT"
          echo "Sync mode: $SYNC_ALL"

      - name: Get changed task files
        id: changed-files
        run: |
          if [ "${{ steps.check-sync-flag.outputs.sync_all }}" = "true" ]; then
            echo "ðŸ”„ Bulk sync mode enabled - processing all tasks"
            FILES=$(find docs/tasks -type f -name '*.md' ! -name '*INDEX*' ! -name '*TEMPLATE*' -print0 | xargs -0)
          else
            FILES=$(git diff --name-only HEAD~1 HEAD | grep -E '^docs/tasks/.*\.md$' | grep -vE '(INDEX|TEMPLATE)' || echo "")
          fi

          # Use multiline output for better handling
          {
            echo "files<<EOF"
            echo "$FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          FILE_COUNT=$(echo "$FILES" | wc -w | tr -d ' ')
          echo "Found $FILE_COUNT task file(s) to process"
          echo "file_count=$FILE_COUNT" >> "$GITHUB_OUTPUT"

      - name: Sync tasks with GitHub issues
        if: steps.changed-files.outputs.file_count > 0
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_PROJECT_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
        run: |
          set -euo pipefail

          # Initialize counters for summary
          CREATED=0
          UPDATED=0
          CLOSED=0
          ERRORS=0

          # Read files from multiline output
          FILES="${{ steps.changed-files.outputs.files }}"

          for file in $FILES; do
            echo "::group::Processing: $file"

            # Skip if file doesn't match expected pattern
            if [[ ! "$file" =~ ^docs/tasks/.*/[0-9]+-.*\.md$ ]]; then
              echo "::warning::Skipping file with unexpected pattern: $file"
              echo "::endgroup::"
              continue
            fi

            # Extract task ID from filename
            TASK_ID=$(basename "$file" | grep -oE '^[0-9]+')

            # Validate task ID
            if [ -z "$TASK_ID" ]; then
              echo "::error::Invalid task ID in filename: $file"
              ((ERRORS++))
              echo "::endgroup::"
              continue
            fi

            # Check if file exists (not deleted)
            if [ ! -f "$file" ]; then
              echo "Task file deleted: $TASK_ID"

              # Find and close existing issue
              ISSUE_NUMBER=$(gh issue list \
                --state all \
                --limit 1000 \
                --search "5daydocs-task-id: $TASK_ID in:body" \
                --json number \
                --jq '.[0].number // empty')

              if [ -n "$ISSUE_NUMBER" ]; then
                gh issue close "$ISSUE_NUMBER" \
                  --comment "Task file deleted from repository" \
                  --reason "not_planned"
                echo "âœ“ Closed issue #$ISSUE_NUMBER"
                ((CLOSED++))
              fi

              echo "::endgroup::"
              continue
            fi

            # Parse task metadata using jq-style extraction where possible
            TASK_TITLE=$(grep -E '^# Task [0-9]+:' "$file" | sed -E 's/^# Task [0-9]+: //' | head -n1)

            # Validate required fields
            if [ -z "$TASK_TITLE" ]; then
              echo "::error::Missing task title in $file (expected format: '# Task ID: Title')"
              ((ERRORS++))
              echo "::endgroup::"
              continue
            fi

            echo "Task ID: $TASK_ID"
            echo "Title: $TASK_TITLE"

            # Extract metadata with safe defaults
            FEATURE=$(grep -E '^\*\*Feature\*\*:' "$file" | sed 's/\*\*Feature\*\*: //' | head -n1 || echo "none")

            # Extract sections using awk for better performance
            PROBLEM=$(awk '/^## Problem$/,/^## Success criteria$/ {if (!/^##/) print}' "$file" | sed '/^$/d' || echo "No description provided")
            CRITERIA=$(awk '/^## Success criteria$/,/^## Notes$|^## / {if (!/^##/) print}' "$file" | sed '/^$/d' || echo "No criteria defined")

            # Determine status and labels based on folder
            case "$file" in
              */backlog/*)
                LABELS="backlog"
                STATUS="Backlog"
                ;;
              */next/*)
                LABELS="next"
                STATUS="Next"
                ;;
              */working/*)
                LABELS="in-progress"
                STATUS="Working"
                ;;
              */review/*)
                LABELS="review"
                STATUS="In Review"
                ;;
              */live/*)
                LABELS="completed"
                STATUS="Live"
                ;;
              *)
                echo "::error::Unknown folder for file: $file"
                ((ERRORS++))
                echo "::endgroup::"
                continue
                ;;
            esac

            echo "Status: $STATUS"

            # Create issue body with metadata
            BODY="<!-- 5daydocs-task-id: $TASK_ID -->

## 5DayDocs Task

**Status**: $STATUS
**Feature**: $FEATURE
**Task File**: \`$file\`

## Problem
$PROBLEM

## Success criteria
$CRITERIA

---
*This issue was automatically synced from the 5DayDocs task management system.*"

            # Search for existing issue by task ID in body
            ISSUE_NUMBER=$(gh issue list \
              --state all \
              --limit 1000 \
              --search "5daydocs-task-id: $TASK_ID in:body" \
              --json number \
              --jq '.[0].number // empty')

            if [ -z "$ISSUE_NUMBER" ]; then
              # Create new issue
              echo "Creating new issue..."

              ISSUE_NUMBER=$(gh issue create \
                --title "Task $TASK_ID: $TASK_TITLE" \
                --body "$BODY" \
                --label "$LABELS" \
                --json number \
                --jq '.number')

              echo "âœ“ Created issue #$ISSUE_NUMBER"
              ((CREATED++))
            else
              # Update existing issue
              echo "Updating existing issue #$ISSUE_NUMBER..."

              # Update title and body
              gh issue edit "$ISSUE_NUMBER" \
                --title "Task $TASK_ID: $TASK_TITLE" \
                --body "$BODY"

              # Sync labels (remove old status labels, add new)
              CURRENT_LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels --jq '.labels[].name' | tr '\n' ' ')

              for old_label in backlog next in-progress review completed; do
                if [[ "$CURRENT_LABELS" == *"$old_label"* ]] && [[ "$old_label" != "$LABELS" ]]; then
                  gh issue edit "$ISSUE_NUMBER" --remove-label "$old_label" 2>/dev/null || true
                fi
              done

              if [[ "$CURRENT_LABELS" != *"$LABELS"* ]]; then
                gh issue edit "$ISSUE_NUMBER" --add-label "$LABELS"
              fi

              # Handle state transitions
              CURRENT_STATE=$(gh issue view "$ISSUE_NUMBER" --json state --jq '.state')

              if [[ "$file" == */live/* ]]; then
                if [ "$CURRENT_STATE" = "OPEN" ]; then
                  gh issue close "$ISSUE_NUMBER" \
                    --comment "Task completed and moved to live" \
                    --reason "completed"
                  echo "âœ“ Closed issue (task completed)"
                fi
              else
                if [ "$CURRENT_STATE" = "CLOSED" ]; then
                  gh issue reopen "$ISSUE_NUMBER"
                  echo "âœ“ Reopened issue (moved from live)"
                fi
              fi

              echo "âœ“ Updated issue #$ISSUE_NUMBER to status: $STATUS"
              ((UPDATED++))
            fi

            # Add to GitHub Project (if configured)
            if [ -n "$PROJECT_NUMBER" ] && [ -n "$GH_PROJECT_TOKEN" ]; then
              echo "Adding to project #$PROJECT_NUMBER..."

              # Temporarily use project token
              export GH_TOKEN="$GH_PROJECT_TOKEN"

              # Add to project (idempotent)
              if gh project item-add "$PROJECT_NUMBER" \
                --owner "@me" \
                --url "https://github.com/${{ github.repository }}/issues/$ISSUE_NUMBER" 2>/dev/null; then
                echo "âœ“ Added to project"
              fi

              # Update project item status
              ITEM_ID=$(gh project item-list "$PROJECT_NUMBER" \
                --owner "@me" \
                --format json \
                --jq ".items[] | select(.content.number == $ISSUE_NUMBER) | .id" 2>/dev/null || echo "")

              if [ -n "$ITEM_ID" ]; then
                if gh project item-edit \
                  --id "$ITEM_ID" \
                  --project-id "$PROJECT_NUMBER" \
                  --field-id "Status" \
                  --text "$STATUS" 2>/dev/null; then
                  echo "âœ“ Updated project status to: $STATUS"
                fi
              fi

              # Restore original token
              export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
            fi

            echo "::endgroup::"
          done

          # Create job summary
          {
            echo "## Task Sync Summary"
            echo ""
            echo "| Metric | Count |"
            echo "|--------|-------|"
            echo "| Created | $CREATED |"
            echo "| Updated | $UPDATED |"
            echo "| Closed | $CLOSED |"
            echo "| Errors | $ERRORS |"
            echo ""
            echo "**Total processed:** $((CREATED + UPDATED + CLOSED))"
          } >> "$GITHUB_STEP_SUMMARY"

          # Fail if there were errors
          if [ "$ERRORS" -gt 0 ]; then
            echo "::error::Sync completed with $ERRORS error(s)"
            exit 1
          fi

          echo "Sync complete!"

      - name: Reset bulk sync flag
        if: steps.check-sync-flag.outputs.sync_all == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Reset the SYNC_ALL_TASKS flag in STATE.md
          if grep -q '^\*\*SYNC_ALL_TASKS\*\*: true' docs/STATE.md; then
            sed -i.bak 's/^\*\*SYNC_ALL_TASKS\*\*: true$/\*\*SYNC_ALL_TASKS\*\*: false/' docs/STATE.md
            rm -f docs/STATE.md.bak

            # Commit the change
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add docs/STATE.md
            git commit -m "Reset SYNC_ALL_TASKS flag after bulk sync"
            git push

            echo "âœ“ Reset SYNC_ALL_TASKS flag"
          fi
